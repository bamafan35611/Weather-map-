<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Mapbox Weather Intelligence â€“ Enhanced Features</title>
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<style>
html, body { height: 100%; margin: 0; padding: 0; }
body { font-family: Arial, Helvetica, sans-serif; }
#map { 
  height: calc(100vh - 48px); 
  border: 3px solid #00ffff !important; 
  border-radius: 4px;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}
header { 
  height: 48px; 
  padding: 8px 12px; 
  background: #0b67a3; 
  color: #fff; 
  display: flex; 
  align-items: center; 
  gap: 12px; 
  border-bottom: 2px solid #ffffff !important; 
}
#radar-timestamp { 
  position: fixed; 
  bottom: 20px; 
  left: 50%; 
  transform: translateX(-50%); 
  background: rgba(0,0,0,0.75); 
  color: #ffff88; 
  padding: 6px 10px; 
  border-radius: 6px; 
  font-size: 14px; 
  font-weight: bold; 
  z-index: 1001; 
  border: 2px solid #ffffff !important; 
}
.status-panel { 
  position: fixed; 
  bottom: 80px; 
  left: 15px; 
  background: rgba(0,0,0,0.8); 
  color: #fff; 
  padding: 12px; 
  border-radius: 8px; 
  font-size: 13px; 
  max-width: 280px; 
  z-index: 1001; 
  box-shadow: 0 0 10px rgba(0,0,0,0.7); 
  border: 2px solid #ffffff !important; 
}
.status-panel h4 { margin: 0 0 8px 0; color: #88ff88; }
.status-panel div { margin-bottom: 4px; }
.weather-briefing { 
  position: fixed; 
  top: 60px; 
  right: 15px; 
  width: 380px; 
  max-height: 450px; 
  background: rgba(0,0,0,0.9); 
  color: #fff; 
  padding: 16px; 
  border-radius: 10px; 
  font-size: 13px; 
  z-index: 1001; 
  box-shadow: 0 0 15px rgba(0,255,255,0.3); 
  border: 2px solid #ffffff !important; 
  overflow-y: auto; 
}
.weather-briefing h3 { margin:0 0 12px 0; color:#00ffff; font-size:16px; text-align:center; }
.hourly-indicator { color: #00ff88; font-weight: bold; }
.forecast-section { margin-top: 10px; padding: 8px; background: rgba(0,255,255,0.1); border-radius: 5px; border: 1px solid rgba(255, 255, 255, 0.5); }
.forecast-section h5 { margin: 0 0 5px 0; color: #88ff88; }
.prediction-section { margin-top: 10px; padding: 8px; background: rgba(255,255,0,0.1); border-radius: 5px; border-left: 3px solid #ffff00; border: 1px solid rgba(255, 255, 255, 0.5); }
.prediction-section h5 { margin: 0 0 5px 0; color: #ffff88; }
.action-button { 
  position: fixed; 
  right: 15px; 
  background: rgba(0,255,255,0.2); 
  border: 1px solid #ffffff; 
  color: #00ffff; 
  padding: 8px 12px; 
  border-radius: 5px; 
  cursor: pointer; 
  font-size: 12px; 
  z-index: 1002; 
  min-width: 80px;
}
.action-button:hover { background: rgba(0,255,255,0.4); }
#enable-voice-button { top: 430px; background: rgba(0,255,0,0.2); border-color: #00ff00; color: #00ff00; }
#analytics-button { top: 470px; }
#predictions-button { top: 510px; }
#preferences-button { top: 550px; }
#history-button { top: 590px; }
#watches-button { top: 630px; background: rgba(255,215,0,0.20); border-color: #ffd700; color: #ffd700; }
#outlooks-button { top: 670px; background: rgba(100,200,255,0.2); border-color: #64c8ff; color: #64c8ff; }
#test-button { top: 710px; background: rgba(255,255,0,0.2); color: #ffff00; }#toggle-briefing-button { top: 390px; background: rgba(0,0,0,0.2); border-color: #ffffff; color: #ffffff; }

.connection-status {
  position: fixed;
  top: 15px;
  right: 15px;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  z-index: 1004;
}
.connection-online {
  background: rgba(0,255,0,0.3);
  color: #88ff88;
  border: 1px solid #00ff00;
}
.connection-offline {
  background: rgba(255,0,0,0.3);
  color: #ff8888;
  border: 1px solid #ff0000;
}

.interactive-panel {
  position: fixed;
  top: 60px;
  left: 15px;
  width: 400px;
  max-height: 500px;
  background: rgba(0,0,0,0.95);
  color: #fff;
  padding: 16px;
  border-radius: 10px;
  font-size: 12px;
  z-index: 1003;
  box-shadow: 0 0 20px rgba(255,255,0,0.3);
  border: 2px solid #ffffff;
  overflow-y: auto;
  display: none;
}
.interactive-panel h3 { margin:0 0 12px 0; color:#ffff00; font-size:16px; text-align:center; }

.close-panel {
  float: right;
  color: #ff6666 !important;
  cursor: pointer !important;
  font-weight: bold;
  font-size: 18px !important;
  padding: 4px 8px !important;
  border-radius: 3px;
  background: rgba(255, 102, 102, 0.2) !important;
  border: 1px solid #ff6666 !important;
}

.close-panel:hover {
  background: rgba(255, 102, 102, 0.4) !important;
  color: #ffffff !important;
  transform: scale(1.1) !important;
}


}
</style>
</head>
<body>
<header>
<strong>Mapbox Weather Intelligence - Enhanced</strong>
<div style="margin-left:auto">Blinking Alerts â€¢ Zoom Counties â€¢ Browser TTS</div>
</header>
<div class="connection-status" id="connection-status">Backend: Connecting...</div>

<div id="map"></div>
<div id="radar-timestamp">Radar: Initializing...</div>
<div class="status-panel" id="status-panel">
<h4>Enhanced Weather Intelligence</h4>
<div>Status: ACTIVE</div>
<div>Radar: <span id="radar-status">Initializing</span></div>
<div>Counties: <span id="county-status">Zoom-Based</span></div>
<div>Current Zoom: <span id="current-zoom">--</span></div>
<div class="hourly-indicator">Alerts: <span id="alert-animation">Animated</span></div>
<div id="threat-level">Threat: LOW</div>
<div id="alerts-count">Alerts: 0</div>
<div id="watches-count">Watches: 0</div>
<div class="confidence-indicator" id="prediction-confidence">AI Confidence: 75%</div>
<div class="next-briefing" id="next-briefing">Next: 60:00</div>
<div class="next-alert-check" id="next-alert-check">Alert Check: 15:00</div>

</div>
<div class="weather-briefing" id="weather-briefing">
<h3>Enhanced Weather Information</h3>
<div id="briefing-content">
<p>Loading enhanced weather system...</p>
<p>Initializing Mapbox GL JS...</p>
<p>Setting up Azure Text-to-Speech...</p>
</div>
</div>
<div class="action-button" id="toggle-briefing-button">Panel: ON</div>
<div class="action-button" id="enable-voice-button">Voice: OFF</div>
<div class="action-button" id="analytics-button">Analytics</div>
<div class="action-button" id="predictions-button">Predictions</div>
<div class="action-button" id="preferences-button">Preferences</div>
<div class="action-button" id="history-button">History</div>
<div class="action-button" id="watches-button">Watches: ON</div>
<div class="action-button" id="outlooks-button">Outlooks: ON</div>
<div class="action-button" id="test-button">Test Backend</div>

<div class="interactive-panel" id="analytics-panel">
<h3>Enhanced Analytics <span class="close-panel" id="close-analytics">âœ•</span></h3>
<div id="analytics-content">Loading enhanced analytics...</div>
</div>
<div class="interactive-panel" id="predictions-panel">
<h3>AI Predictions <span class="close-panel" id="close-predictions">âœ•</span></h3>
<div id="predictions-content">Loading predictions...</div>
</div>
<div class="interactive-panel" id="preferences-panel">
<h3>User Preferences <span class="close-panel" id="close-preferences">âœ•</span></h3>
<div id="preferences-content">Loading preferences...</div>
</div>
<div class="interactive-panel" id="history-panel">
<h3>Weather History <span class="close-panel" id="close-history">âœ•</span></h3>
<div id="history-content">Loading history...</div>
</div>

<script>
function getAlertTitle(alert) {
    if (!alert || !alert.properties) return "Weather Alert";
    if (alert.properties.event) {
        let title = alert.properties.event;
        if (alert.properties && alert.properties.confidence) {
            title += ` (Confidence: ${alert.properties.confidence}%)`;
        }
        return title;
    }
    if (alert.properties.headline) return alert.properties.headline;
    if (alert.properties.description) return alert.properties.description.substring(0, 80) + "...";
    return "Weather Alert";
}

console.log("Starting Mapbox Weather Intelligence - Speech Sync Fixed + 15min Alert Check");

const MAPBOX_TOKEN = 'pk.eyJ1Ijoibm9ydGhiYW1hd3giLCJhIjoiY21mMXZ6aGdlMmhlMjJqcG9qMzQ2MXRmZyJ9.HnDHg4NTHSUVfgBvh4rXWw';
const BACKEND_BASE_URL = 'http://localhost:5000';

let map;
let speechEnabled = false;
let currentForecast = null;
let backendConnected = false;
let connectionRetries = 0;
const maxRetries = 5;
const readAlerts = new Set();
let countyLayerVisible = false;
let outlooksVisible = true;

let activeWarnings = [];
let allActiveAlerts = [];

let autoZoomInProgress = false;




function updateActiveWarnings(alerts) {
    activeWarnings = alerts.filter(alert => {
        const title = getAlertTitle(alert).toLowerCase();
        return title.includes("warning");
    });
    allActiveAlerts = alerts;
    console.log(`[Repeat] Tracking ${activeWarnings.length} active warnings for 15-min re-announcement.`);
}

async function performPeriodicAlertCheck() {
    if (autoZoomInProgress) {
        console.log('[ZoomGuard] Skipping performPeriodicAlertCheck â€” auto-zoom already in progress.');
        return;
    }
    autoZoomInProgress = true;
    try {

    console.log(`[15min Check] Starting periodic warning check...`);
    console.log(`[15min Check] Active warnings count: ${activeWarnings.length}`);
    
    if (activeWarnings.length === 0) {
        console.log("[15min Check] No active warnings to re-zoom to");
        return;
    }
    
    const warningsWithGeometry = activeWarnings.filter(alert => 
        alert.geometry && 
        alert.geometry.coordinates && 
        alert.geometry.coordinates.length > 0
    );
    
    console.log(`[15min Check] Warnings with geometry: ${warningsWithGeometry.length} of ${activeWarnings.length}`);
    
    if (warningsWithGeometry.length === 0) {
        console.log("[15min Check] No warnings have geometry data - cannot zoom");
        return;
    }
    
    const currentBounds = map.getBounds();
    const viewportWarnings = warningsWithGeometry.filter(alert => {
        try {
            const alertFeature = {
                type: 'FeatureCollection',
                features: [alert]
            };
            const alertBounds = turf.bbox(alertFeature);
            const alertCenter = {
                lng: (alertBounds[0] + alertBounds[2]) / 2,
                lat: (alertBounds[1] + alertBounds[3]) / 2
            };
            
            return currentBounds.contains([alertCenter.lng, alertCenter.lat]);
        } catch (error) {
            return false;
        }
    });
    
    console.log(`[15min Check] Warnings in viewport: ${viewportWarnings.length} of ${warningsWithGeometry.length}`);
    
    if (viewportWarnings.length === 0) {
        console.log("[15min Check] No warnings in current viewport");
        return;
    }
    
    const viewportCenter = map.getCenter();
    const viewportZoom = map.getZoom();
    
    console.log(`[15min Check] Cycling through ${viewportWarnings.length} viewport warnings`);
    
    for (let i = 0; i < viewportWarnings.length; i++) {
        const alert = viewportWarnings[i];
        
        console.log(`[15min Check] Processing warning ${i+1}/${viewportWarnings.length}: ${alert.properties?.event}`);
        
        try {
            const alertFeature = {
                type: 'FeatureCollection',
                features: [alert]
            };
            const bounds = turf.bbox(alertFeature);
            
            console.log(`[15min Check] Zooming IN to: ${alert.properties?.event}`);
            
            console.log('ðŸŽ¯ [Map] Auto-zoom to alert bounds at', new Date().toLocaleTimeString());
        map.fitBounds(bounds, { 
                padding: 50, 
                maxZoom: 10,
                duration: 2000 
            });
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            console.log(`[15min Check] Showing popup for: ${alert.properties?.event}`);
            const popup = showAutoAlertPopup(alert);
            
            if (speechEnabled) {
                const alertType = alert.properties?.event || 'Weather Alert';
                const reminderText = `Reminder: ${alertType} is still in effect.`;
                console.log(`[15min Check] Speaking: ${reminderText}`);
                await speakText(reminderText, 'periodic-check');
            }
            
            console.log(`[15min Check] Holding zoomed IN for 30 seconds...`);
            await new Promise(resolve => setTimeout(resolve, 30000));
            
            if (popup && popup.parentNode) {
                popup.remove();
            }
            
            console.log(`[15min Check] Zooming BACK OUT to original position...`);
            console.log('â†©ï¸ [Map] Returning to manual view at', new Date().toLocaleTimeString());
        map.flyTo({
                center: viewportCenter,
                zoom: viewportZoom,
                duration: 2000
            });
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            if (i < viewportWarnings.length - 1) {
                console.log(`[15min Check] Waiting 15 seconds before next warning...`);
                await new Promise(resolve => setTimeout(resolve, 15000));
            }
            
        } catch (error) {
            console.error(`[15min Check] Error processing warning:`, error);
        }
    }
    
    console.log(`[15min Check] Complete - cycled through ${viewportWarnings.length} warnings`);
    } finally {
        autoZoomInProgress = false;
        console.log('[ZoomGuard] autoZoomInProgress cleared.');
    }
}




// Load voices when available (put this near the top of your script, outside any function)
window.speechSynthesis.onvoiceschanged = () => {
    const voices = speechSynthesis.getVoices();
    console.log(`Loaded ${voices.length} voices`);
};

async function speakText(text, priority = 'normal') {
    if (!speechEnabled) {
        return Promise.resolve();
    }
    
    let cleanText = text
        .replace(/&amp;/g, 'and')
        .replace(/&lt;/g, 'less than')
        .replace(/&gt;/g, 'greater than')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&nbsp;/g, ' ')
        .replace(/\*/g, '')
        .replace(/\s+/g, ' ')
        .replace(/\bAL\b/g, 'Alabama')
        .replace(/\bAK\b/g, 'Alaska')
        .replace(/\bAZ\b/g, 'Arizona')
        .replace(/\bAR\b/g, 'Arkansas')
        .replace(/\bCA\b/g, 'California')
        .replace(/\bCO\b/g, 'Colorado')
        .replace(/\bCT\b/g, 'Connecticut')
        .replace(/\bDE\b/g, 'Delaware')
        .replace(/\bFL\b/g, 'Florida')
        .replace(/\bGA\b/g, 'Georgia')
        .replace(/\bHI\b/g, 'Hawaii')
        .replace(/\bID\b/g, 'Idaho')
        .replace(/\bIL\b/g, 'Illinois')
        .replace(/\bIN\b/g, 'Indiana')
        .replace(/\bIA\b/g, 'Iowa')
        .replace(/\bKS\b/g, 'Kansas')
        .replace(/\bKY\b/g, 'Kentucky')
        .replace(/\bLA\b/g, 'Louisiana')
        .replace(/\bME\b/g, 'Maine')
        .replace(/\bMD\b/g, 'Maryland')
        .replace(/\bMA\b/g, 'Massachusetts')
        .replace(/\bMI\b/g, 'Michigan')
        .replace(/\bMN\b/g, 'Minnesota')
        .replace(/\bMS\b/g, 'Mississippi')
        .replace(/\bMO\b/g, 'Missouri')
        .replace(/\bMT\b/g, 'Montana')
        .replace(/\bNE\b/g, 'Nebraska')
        .replace(/\bNV\b/g, 'Nevada')
        .replace(/\bNH\b/g, 'New Hampshire')
        .replace(/\bNJ\b/g, 'New Jersey')
        .replace(/\bNM\b/g, 'New Mexico')
        .replace(/\bNY\b/g, 'New York')
        .replace(/\bNC\b/g, 'North Carolina')
        .replace(/\bND\b/g, 'North Dakota')
        .replace(/\bOH\b/g, 'Ohio')
        .replace(/\bOK\b/g, 'Oklahoma')
        .replace(/\bOR\b/g, 'Oregon')
        .replace(/\bPA\b/g, 'Pennsylvania')
        .replace(/\bRI\b/g, 'Rhode Island')
        .replace(/\bSC\b/g, 'South Carolina')
        .replace(/\bSD\b/g, 'South Dakota')
        .replace(/\bTN\b/g, 'Tennessee')
        .replace(/\bTX\b/g, 'Texas')
        .replace(/\bUT\b/g, 'Utah')
        .replace(/\bVT\b/g, 'Vermont')
        .replace(/\bVA\b/g, 'Virginia')
        .replace(/\bWA\b/g, 'Washington')
        .replace(/\bWV\b/g, 'West Virginia')
        .replace(/\bWI\b/g, 'Wisconsin')
        .replace(/\bWY\b/g, 'Wyoming')
        .trim();
    
    return new Promise((resolve) => {
        if ('speechSynthesis' in window) {
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 0.95;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            const voices = speechSynthesis.getVoices();
            const naturalVoice = voices.find(v => 
                v.name.includes('Andrew Online (Natural)') || 
                v.name.includes('Brian Online (Natural)') ||
                v.name.includes('Guy Online (Natural)')
            );
            
            if (naturalVoice) {
                utterance.voice = naturalVoice;
                console.log(`ðŸŽ™ï¸ Using voice: ${naturalVoice.name}`);
            } else {
                console.log('âš ï¸ Natural voice not found, using default browser voice');
            }
            
            utterance.onend = () => resolve(true);
            utterance.onerror = () => resolve(false);
            
            speechSynthesis.speak(utterance);
        } else {
            resolve(false);
        }
    });
}


function setupCloseButtons() {
    const closeButtons = [
        { id: 'close-analytics', panelId: 'analytics-panel' },
        { id: 'close-predictions', panelId: 'predictions-panel' },
        { id: 'close-preferences', panelId: 'preferences-panel' },
        { id: 'close-history', panelId: 'history-panel' }
    ];
    
    closeButtons.forEach(({ id, panelId }) => {
        const button = document.getElementById(id);
        const panel = document.getElementById(panelId);
        
        if (button && panel) {
            button.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                panel.style.display = 'none';
                return false;
            });
        }
    });
    
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            const visiblePanels = document.querySelectorAll('.interactive-panel[style*="block"]');
            visiblePanels.forEach(panel => {
                panel.style.display = 'none';
            });
        }
    });
}

function initializeMap() {
    console.log("Initializing Mapbox GL JS...");
    
    mapboxgl.accessToken = MAPBOX_TOKEN;
    
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/dark-v10',
        center: [-86.7816, 34.7304],
        zoom: 7.5,
        projection: 'mercator'
    });
    
    map.on('load', () => {
        console.log("Mapbox map loaded successfully");
        
        addStateBorders();
        addRadarLayer();
        setupCountyVisibility();
        fetchAlerts();
        
        console.log("Enhanced weather system ready!");
    });
    
    map.on('zoom', updateCountyVisibility);
    map.on('move', updateZoomDisplay);
}

async function addStateBorders() {
    try {
        console.log("Loading all US state borders...");
        const response = await fetch('https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json');
        const stateData = await response.json();
        
        map.addSource('states', {
            type: 'geojson',
            data: stateData
        });
        
        map.addLayer({
            id: 'state-borders',
            type: 'line',
            source: 'states',
            paint: {
                'line-color': '#ffffff',
                'line-width': 2.5,
                'line-opacity': 0.8
            }
        });
        
        console.log("All US state borders added");
    } catch (error) {
        console.error("Error loading state borders:", error);
    }
}

function addRadarLayer() {
    console.log("Adding NEXRAD radar layer...");
    
    map.addSource('radar', {
        type: 'raster',
        tiles: [`https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png?_t=${Date.now()}`],
        tileSize: 256
    });
    
    map.addLayer({
        id: 'radar-layer',
        type: 'raster',
        source: 'radar',
        paint: {
            'raster-opacity': 0.6
        }
    });
    
    updateRadarStatus("Live - NEXRAD");
    updateRadarTimestamp();
    
    setInterval(refreshRadar, 120000);
}

function setupCountyVisibility() {
    console.log("Setting up zoom-based county visibility...");
    
    fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json')
        .then(response => response.json())
        .then(countyData => {
            map.addSource('counties', {
                type: 'geojson',
                data: countyData
            });
            
            map.addLayer({
                id: 'county-borders',
                type: 'line',
                source: 'counties',
                paint: {
                    'line-color': '#ffffff',
                    'line-width': 0.3,
                    'line-opacity': 0
                }
            });
            
            map.addLayer({
                id: 'county-labels',
                type: 'symbol',
                source: 'counties',
                layout: {
                    'text-field': ['get', 'NAME'],
                    'text-font': ['Open Sans Regular'],
                    'text-size': 10,
                    'text-anchor': 'center'
                },
                paint: {
                    'text-color': '#ffffff',
                    'text-opacity': 0
                }
            });
            
            updateCountyVisibility();
            console.log("County system ready");
        })
        .catch(error => {
            console.error("Error loading counties:", error);
        });
}

function updateCountyVisibility() {
    const currentZoom = map.getZoom();
    const shouldShowCounties = currentZoom >= 8;
    
    if (shouldShowCounties && !countyLayerVisible) {
        map.setPaintProperty('county-borders', 'line-opacity', 1.0);
        map.setPaintProperty('county-labels', 'text-opacity', 0.7);
        countyLayerVisible = true;
        document.getElementById('county-status').textContent = 'Visible';
    } else if (!shouldShowCounties && countyLayerVisible) {
        map.setPaintProperty('county-borders', 'line-opacity', 0);
        map.setPaintProperty('county-labels', 'text-opacity', 0);
        countyLayerVisible = false;
        document.getElementById('county-status').textContent = 'Hidden';
    }
}

async function handleNewAlerts(newAlerts) {
    if (autoZoomInProgress) {
        console.log('[ZoomGuard] Skipping handleNewAlerts â€” auto-zoom already in progress.');
        return;
    }
    autoZoomInProgress = true;
    try {

    console.log(`Handling ${newAlerts.length} new alerts with speech-synchronized zoom`);
    
    const viewportCenter = map.getCenter();
    const viewportZoom = map.getZoom();
    
    for (let i = 0; i < newAlerts.length; i++) {
        const alert = newAlerts[i];
        
        try {
            const alertFeature = {
                type: 'FeatureCollection',
                features: [alert]
            };
            const bounds = turf.bbox(alertFeature);
            
            console.log(`Processing alert ${i+1}/${newAlerts.length}: ${getAlertTitle(alert)}`);
            
            console.log("Zooming IN to alert...");
            console.log('ðŸŽ¯ [Map] Auto-zoom to alert bounds at', new Date().toLocaleTimeString());
        map.fitBounds(bounds, {
                padding: 50,
                maxZoom: 10,
                duration: 2000
            });
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            console.log("Showing alert popup...");
            const popup = showAutoAlertPopup(alert);
            
            if (speechEnabled) {
                let alertText = `${alert.properties.priority} priority ${alert.properties.event} for ${alert.properties.areaDesc}. ${(alert.properties.description || alert.properties.headline || '').substring(0, 150)}`;
                
                console.log("Speaking alert - map will stay zoomed for 30 seconds...");
                
                speakText(alertText, 'alert');
                
                console.log("Holding zoom for 30 seconds...");
                await new Promise(resolve => setTimeout(resolve, 30000));
                
                console.log("30 seconds complete - now zooming out...");
            } else {
                console.log("Speech disabled - holding zoom for 8 seconds...");
                await new Promise(resolve => setTimeout(resolve, 8000));
            }
            
            if (popup && popup.parentNode) {
                popup.remove();
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            console.log("Zooming BACK OUT to viewport...");
            console.log('â†©ï¸ [Map] Returning to manual view at', new Date().toLocaleTimeString());
        map.flyTo({
                center: viewportCenter,
                zoom: viewportZoom,
                duration: 2000
            });
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            if (i < newAlerts.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 5000));
            }
            
        } catch (alertError) {
            console.error(`Error handling alert:`, alertError);
        }
    }
    
    console.log("Alert processing complete - speech synchronized");
    } finally {
        autoZoomInProgress = false;
        console.log('[ZoomGuard] autoZoomInProgress cleared.');
    }

}

async function fetchAlerts() {
    console.log('âš ï¸ [Alerts] Fetching new alerts at', new Date().toLocaleTimeString());
    try {
        console.log("Fetching weather alerts...");
        
        let prioritizedAlerts = [];
        
        try {
            const backendResponse = await fetch(`${BACKEND_BASE_URL}/api/weather/alerts`, {
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                timeout: 5000
            });
            
            if (backendResponse.ok) {
                const backendData = await backendResponse.json();
                prioritizedAlerts = (backendData.alerts || []).map(alert => ({
                    ...alert,
                    priority: 'HIGH',
                    source: 'monitored_counties'
                }));
                console.log(`Found ${prioritizedAlerts.length} high-priority alerts from backend`);
            }
        } catch (backendError) {
            console.warn("Backend API unavailable, using NWS only:", backendError.message);
        }
        
        console.log("Fetching national alerts from NWS...");
        const nationalResponse = await fetch('https://api.weather.gov/alerts/active', {
            headers: {'Accept': 'application/geo+json'},
            timeout: 10000
        });
        
        if (!nationalResponse.ok) {
            throw new Error(`NWS API error: ${nationalResponse.status}`);
        }
        
        const nationalData = await nationalResponse.json();
        const nationalFeatures = (nationalData.features || []);
        
        console.log(`Retrieved ${nationalFeatures.length} national alerts`);
        
        const processedNationalAlerts = nationalFeatures.map(feature => { const alert = feature.properties;
            const isWatch = alert.event && alert.event.toLowerCase().includes('watch');
            let watchType = null;
            if (isWatch) {
                const ev = alert.event.toLowerCase();
                watchType = ev.includes('tornado') ? 'TOR' : (ev.includes('severe thunderstorm') ? 'SVR' : 'OTHER');
            }
            
            const areaDesc = (alert.areaDesc || '').toLowerCase();
            
            let priority = 'LOW';
            let isWarning = alert.event.toLowerCase().includes('warning');
            
            const northAlabamaCounties = [
                'colbert county', 'cullman county', 'dekalb county', 'franklin county',
                'jackson county', 'lawrence county', 'lauderdale county', 'limestone county',
                'madison county', 'marshall county', 'morgan county'
            ];
            
            if (northAlabamaCounties.some(county => areaDesc.includes(county))) {
                priority = 'HIGH';
            } else if (areaDesc.includes('alabama')) {
                priority = 'MEDIUM';
            } else if (areaDesc.includes('tennessee') || areaDesc.includes('georgia')) {
                priority = 'MEDIUM';
            }
            
            return { ...feature, properties: { ...alert,
                     isWatch: isWatch, watchType: watchType,
                    
                    priority: priority,
                    isWarning: isWarning,
                    color: getAlertColor(alert.event),
                    id: alert.id,
                    source: 'nws_national'
                 } }; });
        
        const localAlertIds = new Set(prioritizedAlerts.map(a => a.id));
        const uniqueNationalAlerts = processedNationalAlerts.filter(a => !localAlertIds.has(a.properties.id));
        
        const backendAlertsGeoJSON = prioritizedAlerts.map(alert => ({
            type: 'Feature',
            properties: {
                ...alert,
                isWarning: (alert.event || alert.properties?.event || '').toLowerCase().includes('warning'),
                color: getAlertColor(alert.event || alert.properties?.event || 'unknown'),
                source: 'monitored_counties',
                isWatch: (alert.event || alert.properties?.event || '').toLowerCase().includes('watch'),
                watchType: ((alert.event || alert.properties?.event || '').toLowerCase().includes('tornado') ? 'TOR' : ((alert.event || alert.properties?.event || '').toLowerCase().includes('severe thunderstorm') ? 'SVR' : 'OTHER'))},
            geometry: alert.geometry
        }));
        
        const allAlerts = [...backendAlertsGeoJSON, ...uniqueNationalAlerts];
const torWatches = allAlerts.filter(a => a.properties && a.properties.isWatch && a.properties.watchType === 'TOR').length;
const svrWatches = allAlerts.filter(a => a.properties && a.properties.isWatch && a.properties.watchType === 'SVR').length;
console.log(`[Watches] Parsed TOR: ${torWatches}, SVR: ${svrWatches}, total: ${torWatches + svrWatches}`);
        
        console.log(`Total alerts: ${allAlerts.length} (${prioritizedAlerts.length} backend priority, ${uniqueNationalAlerts.length} national)`);
        
        updateActiveWarnings(allAlerts);
        addAlertsToMap(allAlerts);
        
        const currentZoom = map.getZoom();
        const currentBounds = map.getBounds();
        let newAlerts = [];
        
        allAlerts.forEach(alert => {
            if (!readAlerts.has(alert.properties.id)) {
                let shouldAutoProcess = false;
                
                if (alert.geometry && alert.geometry.coordinates) {
                    try {
                        const alertFeature = {
                            type: 'FeatureCollection',
                            features: [alert]
                        };
                        const alertBounds = turf.bbox(alertFeature);
                        const alertCenter = {
                            lng: (alertBounds[0] + alertBounds[2]) / 2,
                            lat: (alertBounds[1] + alertBounds[3]) / 2
                        };
                        
                        const isInViewport = currentBounds.contains([alertCenter.lng, alertCenter.lat]);
                        
                        if (alert.properties.priority === 'HIGH') {
                            shouldAutoProcess = isInViewport;
                        } else if (currentZoom <= 7.0 && isInViewport) {
                            shouldAutoProcess = true;
                        }
                    } catch (error) {
                        console.warn("Error checking alert viewport:", error);
                    }
                }
                
                if (shouldAutoProcess) {
                    newAlerts.push(alert);
                }
                
                readAlerts.add(alert.properties.id);
            }
        });
        
        if (newAlerts.length > 0) {
            console.log(`Processing ${newAlerts.length} viewport-visible alerts`);
            handleNewAlerts(newAlerts);
        } else {
            console.log("No new alerts in current viewport to process");
        }
        
        const mappableAlerts = allAlerts.filter(a => a.geometry && a.geometry.coordinates && a.geometry.coordinates.length > 0);
const torCount = mappableAlerts.filter(a => a.properties && a.properties.isWatch && a.properties.watchType === 'TOR').length;
const svrCount = mappableAlerts.filter(a => a.properties && a.properties.isWatch && a.properties.watchType === 'SVR').length;
const watchCount = torCount + svrCount;
const watchEl = document.getElementById('watches-count');
if (watchEl) { watchEl.textContent = `Watches: ${watchCount} (${torCount} TOR / ${svrCount} SVR)`; }

const highPriorityCount = mappableAlerts.filter(a => a.properties.priority === 'HIGH').length;
document.getElementById('alerts-count').textContent = `Alerts: ${mappableAlerts.length} (${highPriorityCount} priority)`;
        
    } catch (error) {
        console.error("Error fetching alerts:", error);
        document.getElementById('alerts-count').textContent = `Alerts: Error`;
    }
}

function addAlertsToMap(alerts) {
    // Remove existing watch layers if present
    if (map.getLayer('watch-fills')) map.removeLayer('watch-fills');
    if (map.getLayer('watch-borders')) map.removeLayer('watch-borders');

    if (map.getLayer('alert-fills')) map.removeLayer('alert-fills');
    if (map.getLayer('alert-borders')) map.removeLayer('alert-borders');
    if (map.getLayer('warning-pulse')) map.removeLayer('warning-pulse');
    if (map.getSource('alerts')) map.removeSource('alerts');
    
    const alertsGeoJSON = {
        type: 'FeatureCollection',
        features: alerts
    };
    
    map.addSource('alerts', {
        type: 'geojson',
        data: alertsGeoJSON
    });
    
    map.addLayer({
        id: 'alert-fills',
        type: 'fill',
        source: 'alerts',
        paint: {
            'fill-color': ['get', 'color'],
            'fill-opacity': 0.3
        }
    });
    
    map.addLayer({
        id: 'alert-borders',
        type: 'line',
        source: 'alerts',
        paint: {
            'line-color': ['get', 'color'],
            'line-width': [
                'case',
                ['==', ['get', 'priority'], 'HIGH'], 4,
                ['==', ['get', 'isWarning'], true], 3,
                2
            ],
            'line-opacity': 0.8
        }
    });
    
    
    map.addLayer({
        id: 'warning-pulse',
        type: 'line',
        source: 'alerts',
        filter: ['==', ['get', 'isWarning'], true],
        paint: {
            'line-color': ['get', 'color'],
            'line-width': 6,
            'line-opacity': ['interpolate', ['linear'], ['zoom'], 5, 0.8, 15, 0.6]
        }
    });

    
    // === Dedicated Tornado/Severe Thunderstorm WATCH visualization ===
    // Insert fills BETWEEN alert-fills and alert-borders
    map.addLayer({
        id: 'watch-fills',
        type: 'fill',
        source: 'alerts',
        filter: ['all',
            ['==', ['get', 'isWatch'], true],
            ['any', ['==', ['get', 'watchType'], 'TOR'], ['==', ['get', 'watchType'], 'SVR']]
        ],
        paint: {
            'fill-color': [
                'match', ['get', 'watchType'],
                'TOR', '#FFD700',    /* Tornado Watch */
                'SVR', '#FFFF66',    /* Severe T-Storm Watch */
                '#CCCC66'
            ],
            'fill-opacity': 0.28
        }
    }, 'alert-borders'); // before alert-borders so it sits above alert-fills

    // Put borders at the very top (after warning-pulse)
    map.addLayer({
        id: 'watch-borders',
        type: 'line',
        source: 'alerts',
        filter: ['all',
            ['==', ['get', 'isWatch'], true],
            ['any', ['==', ['get', 'watchType'], 'TOR'], ['==', ['get', 'watchType'], 'SVR']]
        ],
        paint: {
            'line-color': [
                'match', ['get', 'watchType'],
                'TOR', '#FFD700',
                'SVR', '#FFFF66',
                '#CCCC66'
            ],
            'line-width': 2.5,
            'line-opacity': 1.0,
            'line-dasharray': ['match', ['get', 'watchType'], 'SVR', ['literal', [3, 2]], ['literal', [1, 0]]]
        }
    });

    // Click handling for watch areas
    map.on('click', 'watch-fills', (e) => {
        const alert = e.features[0].properties;
        showAlertPopup(e, alert);
    });
    map.on('mouseenter', 'watch-fills', () => { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'watch-fills', () => { map.getCanvas().style.cursor = ''; });
// Click handling for watch areas
    map.on('click', 'watch-fills', (e) => {
        const alert = e.features[0].properties;
        showAlertPopup(e, alert);
    });
    map.on('mouseenter', 'watch-fills', () => { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'watch-fills', () => { map.getCanvas().style.cursor = ''; });

    console.log('[Watches] watch-fills and watch-borders added to map');

    animateWarnings();
    
    map.on('click', 'alert-fills', (e) => {
        const alert = e.features[0].properties;
        showAlertPopup(e, alert);
    });
    
    map.on('mouseenter', 'alert-fills', () => {
        map.getCanvas().style.cursor = 'pointer';
    });
    
    map.on('mouseleave', 'alert-fills', () => {
        map.getCanvas().style.cursor = '';
    });
    
    console.log(`Added ${alerts.length} alerts to map`);
}
async function fetchOutlooks() {
    try {
        console.log('Fetching weather outlooks...');
        const response = await fetch(`${BACKEND_BASE_URL}/api/outlooks`);
        if (!response.ok) {
            console.warn('Outlooks API unavailable');
            return;
        }
        const data = await response.json();
        const outlooks = data.outlooks || [];
        console.log(`Retrieved ${outlooks.length} weather outlooks`);
        if (outlooks.length > 0) {
            addOutlooksToMap(outlooks);
        }
    } catch (error) {
        console.error("Error fetching outlooks:", error);
    }
}

function addOutlooksToMap(outlooks) {
    if (map.getLayer('outlook-fills')) map.removeLayer('outlook-fills');
    if (map.getLayer('outlook-borders')) map.removeLayer('outlook-borders');
    if (map.getSource('outlooks')) map.removeSource('outlooks');
    const features = outlooks.map(outlook => ({
        type: 'Feature',
        properties: {
            type: outlook.type,
            risk_level: outlook.risk_level,
            probability: outlook.probability,
            description: outlook.description,
            day: outlook.day
        },
        geometry: {
            type: 'Polygon',
            coordinates: [outlook.polygon]
        }
    }));
    const outlooksGeoJSON = { type: 'FeatureCollection', features: features };
    map.addSource('outlooks', { type: 'geojson', data: outlooksGeoJSON });
    map.addLayer({
        id: 'outlook-fills',
        type: 'fill',
        source: 'outlooks',
        paint: {
            'fill-color': ['match', ['get', 'risk_level'], 'MRGL', '#66ff66', 'SLGT', '#ffff00', 'ENH', '#ff9900', 'MDT', '#ff0000', 'HIGH', '#ff00ff', 'SLIGHT', '#66ccff', '#888888'],
            'fill-opacity': 0.2
        }
    });
    map.addLayer({
        id: 'outlook-borders',
        type: 'line',
        source: 'outlooks',
        paint: {
            'line-color': ['match', ['get', 'risk_level'], 'MRGL', '#66ff66', 'SLGT', '#ffff00', 'ENH', '#ff9900', 'MDT', '#ff0000', 'HIGH', '#ff00ff', 'SLIGHT', '#66ccff', '#888888'],
            'line-width': 2,
            'line-opacity': 0.6
        }
    });
    
    map.on('click', 'outlook-fills', (e) => {
        const outlook = e.features[0].properties;
        showOutlookPopup(e, outlook);
    });
    
    map.on('mouseenter', 'outlook-fills', () => {
        map.getCanvas().style.cursor = 'pointer';
    });
    
    map.on('mouseleave', 'outlook-fills', () => {
        map.getCanvas().style.cursor = '';
    });
    
    console.log(`Added ${features.length} outlooks to map`);
}

function toggleWatches() {
    const btn = document.getElementById('watches-button');
    if (!map) return;
    const visible = (map.getLayer('watch-fills') && map.getLayoutProperty('watch-fills', 'visibility') !== 'none');
    const next = visible ? 'none' : 'visible';
    if (map.getLayer('watch-fills')) map.setLayoutProperty('watch-fills', 'visibility', next);
    if (map.getLayer('watch-borders')) map.setLayoutProperty('watch-borders', 'visibility', next);
    if (btn) {
        btn.textContent = next === 'visible' ? 'Watches: ON' : 'Watches: OFF';
        btn.style.backgroundColor = next === 'visible' ? 'rgba(255,215,0,0.20)' : 'rgba(255,120,120,0.20)';
    }
}


 
function toggleOutlooks() {
    outlooksVisible = !outlooksVisible;
    const btn = document.getElementById('outlooks-button');
    
    if (outlooksVisible) {
        btn.textContent = 'Outlooks: ON';
        btn.style.backgroundColor = 'rgba(100,200,255,0.2)';
        if (map.getLayer('outlook-fills')) {
            map.setLayoutProperty('outlook-fills', 'visibility', 'visible');
            map.setLayoutProperty('outlook-borders', 'visibility', 'visible');
        }
    } else {
        btn.textContent = 'Outlooks: OFF';
        btn.style.backgroundColor = 'rgba(255,100,100,0.2)';
        if (map.getLayer('outlook-fills')) {
            map.setLayoutProperty('outlook-fills', 'visibility', 'none');
            map.setLayoutProperty('outlook-borders', 'visibility', 'none');
        }
    }
}
function showOutlookPopup(e, outlook) {
    const existingPopups = document.querySelectorAll('.custom-outlook-popup');
    existingPopups.forEach(popup => popup.remove());
    const riskColors = {'MRGL': '#66ff66','SLGT': '#ffff00','ENH': '#ff9900','MDT': '#ff0000','HIGH': '#ff00ff','SLIGHT': '#66ccff'};
    const color = riskColors[outlook.risk_level] || '#888888';
    const popup = document.createElement('div');
    popup.className = 'custom-outlook-popup';
    popup.style.cssText = `position: fixed;background: rgba(0,0,0,0.9);color: white;padding: 15px;border-radius: 8px;border: 2px solid ${color};min-width: 250px;max-width: 350px;z-index: 10000;box-shadow: 0 4px 12px rgba(0,0,0,0.5);font-family: Arial, sans-serif;`;
    const closeBtn = document.createElement('button');
    closeBtn.innerHTML = 'Ã—';
    closeBtn.style.cssText = 'position: absolute;top: 8px;right: 8px;width: 24px;height: 24px;background: #ff6666;color: white;border: none;border-radius: 50%;cursor: pointer;font-size: 16px;font-weight: bold;z-index: 10001;';
    closeBtn.addEventListener('click', function(e) {e.preventDefault();e.stopPropagation();popup.remove();});
    const content = document.createElement('div');
    content.innerHTML = `<h4 style="margin: 0 0 8px 0; color: ${color}; padding-right: 30px;">SPC Outlook - Day ${outlook.day}</h4><div style="margin: 4px 0; padding: 4px 8px; background: ${color}; color: black; border-radius: 3px; font-size: 11px; font-weight: bold; display: inline-block;">${outlook.risk_level} RISK</div><p style="margin: 8px 0 4px 0; font-size: 12px;"><strong>Type:</strong> ${outlook.type.replace('_', ' ').toUpperCase()}</p><p style="margin: 4px 0; font-size: 12px;"><strong>Probability:</strong> ${outlook.probability}</p><p style="margin: 4px 0; font-size: 12px;"><strong>Description:</strong> ${outlook.description}</p><div style="margin-top: 10px;"><button style="padding: 6px 10px;background: #666;color: white;border: none;border-radius: 3px;cursor: pointer;font-size: 11px;" onclick="this.closest('.custom-outlook-popup').remove()">Close</button></div>`;
    popup.appendChild(closeBtn);
    popup.appendChild(content);
    const mapContainer = document.getElementById('map');
    const mapRect = mapContainer.getBoundingClientRect();
    const clickX = e.originalEvent.clientX - mapRect.left;
    const clickY = e.originalEvent.clientY - mapRect.top;
    popup.style.left = Math.min(clickX + 10, mapRect.width - 370) + 'px';
    popup.style.top = Math.min(clickY + 10, mapRect.height - 200) + 'px';
    mapContainer.appendChild(popup);
    setTimeout(() => {const clickOutsideHandler = (event) => {if (!popup.contains(event.target)) {popup.remove();document.removeEventListener('click', clickOutsideHandler);}};document.addEventListener('click', clickOutsideHandler);}, 100);
}
function animateWarnings() {
    let isVisible = true;
    
    function blink() {
        const opacity = isVisible ? 0.9 : 0.1;
        
        if (map.getLayer('warning-pulse')) {
            map.setPaintProperty('warning-pulse', 'line-opacity', opacity);
        }
        
        isVisible = !isVisible;
        setTimeout(blink, 800);
    }
    
    blink();
}

function showAlertPopup(e, alert) {
    const existingPopups = document.querySelectorAll('.custom-alert-popup');
    existingPopups.forEach(popup => popup.remove());
    
    const popup = document.createElement('div');
    popup.className = 'custom-alert-popup';
    popup.style.cssText = `
        position: fixed;
        background: rgba(0,0,0,0.9);
        color: white;
        padding: 15px;
        border-radius: 8px;
        border: 2px solid ${alert.color};
        min-width: 250px;
        max-width: 350px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        font-family: Arial, sans-serif;
    `;
    
    const closeBtn = document.createElement('button');
    closeBtn.innerHTML = 'Ã—';
    closeBtn.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: #ff6666;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
    `;
    
    closeBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        popup.remove();
    });
    
    const content = document.createElement('div');
    content.innerHTML = `
        <h4 style="margin: 0 0 8px 0; color: ${alert.color}; padding-right: 30px;">${alert.event}</h4>
        <div style="margin: 4px 0; padding: 2px 6px; background: ${alert.priority === 'HIGH' ? '#ff4444' : '#ffaa44'}; color: white; border-radius: 3px; font-size: 10px; display: inline-block;">
            ${alert.priority} PRIORITY ${alert.isWarning ? '- WARNING' : ''}
        </div>
        <p style="margin: 8px 0 4px 0; font-size: 12px;"><strong>Headline:</strong> ${alert.headline}</p>
        <p style="margin: 4px 0; font-size: 12px;"><strong>Areas:</strong> ${alert.areaDesc}</p>
        <p style="margin: 4px 0 8px 0; font-size: 11px;"><strong>Expires:</strong> ${new Date(alert.expires).toLocaleString()}</p>
        
        <div style="margin-top: 10px;">
            <button style="
                margin: 4px 0;
                padding: 6px 10px;
                background: #666;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
                font-size: 11px;
            " onclick="this.closest('.custom-alert-popup').remove()">Close</button>
        </div>
    `;
    
    popup.appendChild(closeBtn);
    popup.appendChild(content);
    
    const mapContainer = document.getElementById('map');
    const mapRect = mapContainer.getBoundingClientRect();
    
    const clickX = e.originalEvent.clientX - mapRect.left;
    const clickY = e.originalEvent.clientY - mapRect.top;
    
    popup.style.left = Math.min(clickX + 10, mapRect.width - 370) + 'px';
    popup.style.top = Math.min(clickY + 10, mapRect.height - 200) + 'px';
    
    mapContainer.appendChild(popup);
    
    setTimeout(() => {
        const clickOutsideHandler = (event) => {
            if (!popup.contains(event.target)) {
                popup.remove();
                document.removeEventListener('click', clickOutsideHandler);
            }
        };
        document.addEventListener('click', clickOutsideHandler);
    }, 100);
    
    return popup;
}

function showAutoAlertPopup(alert) {
    const existingAutoPopups = document.querySelectorAll('.auto-alert-popup');
    existingAutoPopups.forEach(popup => popup.remove());
    
    const popup = document.createElement('div');
    popup.className = 'auto-alert-popup';
    popup.style.cssText = `
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(0,0,0,0.95);
        color: white;
        padding: 12px;
        border-radius: 8px;
        border: 2px solid ${alert.properties.color || '#ff6666'};
        width: 280px;
        z-index: 10000;
        box-shadow: 0 6px 16px rgba(0,0,0,0.8);
        font-family: Arial, sans-serif;
        animation: alertPopupSlide 0.3s ease-in;
        pointer-events: none;
    `;
    
    const style = document.createElement('style');
    style.textContent = `
        @keyframes alertPopupSlide {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
    `;
    document.head.appendChild(style);
    
    const content = document.createElement('div');
    content.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <div style="background: ${alert.properties.priority === 'HIGH' ? '#ff4444' : '#ffaa44'}; color: white; padding: 3px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; margin-right: 8px;">
                ${alert.properties.priority}
            </div>
            <div style="font-size: 11px; color: #ffff88;">
                ${alert.properties.isWarning ? 'WARNING' : 'ALERT'}
            </div>
        </div>
        
        <h4 style="margin: 0 0 8px 0; color: ${alert.properties.color || '#ff6666'}; font-size: 14px; line-height: 1.2;">
            ${alert.properties.event || 'Weather Alert'}
        </h4>
        
        <div style="background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px; margin: 8px 0;">
            <p style="margin: 0; font-size: 11px; line-height: 1.3;">
                ${(alert.properties.headline || 'Weather alert in effect').substring(0, 120)}${(alert.properties.headline || '').length > 120 ? '...' : ''}
            </p>
        </div>
        
        <div style="margin: 6px 0;">
            <p style="margin: 0; font-size: 10px; color: #cccccc;">
                <strong style="color: #88ffff;">Areas:</strong> ${(alert.properties.areaDesc || 'Multiple areas').substring(0, 50)}${(alert.properties.areaDesc || '').length > 50 ? '...' : ''}
            </p>
        </div>
        
        <div style="margin-top: 8px; padding: 6px; background: rgba(255,255,0,0.2); border-radius: 4px;">
            <p style="margin: 0; font-size: 9px; color: #ffff88; text-align: center;">
                Map stays zoomed until speech completes
            </p>
        </div>
    `;
    
    popup.appendChild(content);
    
    const mapContainer = document.getElementById('map');
    mapContainer.appendChild(popup);
    
    console.log('Auto alert popup created - map will stay zoomed until speech finishes');
    
    return popup;
}

function getAlertColor(eventType) {
    const eventColors = {
        "Tornado Warning": "#FF0000",
        "Tornado Watch": "#FFD700", 
        "Severe Thunderstorm Warning": "#FFA500",
        "Severe Thunderstorm Watch": "#FFFF00",
        "Flash Flood Warning": "#8B0000",
        "Flash Flood Watch": "#00FF00",
        "Flood Warning": "#00CED1",
        "Flood Watch": "#98FB98",
        "Special Weather Statement": "#C0C0C0",
        "Winter Storm Warning": "#FF69B4",
        "Winter Weather Advisory": "#DDA0DD"
    };
    
    return eventColors[eventType] || '#808080';
}

function refreshRadar() {
    if (map.getSource('radar')) {
        map.getSource('radar').tiles = [`https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png?_t=${Date.now()}`];
        updateRadarTimestamp();
    }
}

function updateRadarStatus(status) {
    const statusEl = document.getElementById('radar-status');
    if (statusEl) statusEl.textContent = status;
}

function updateRadarTimestamp() {
    const timestampEl = document.getElementById("radar-timestamp");
    if (timestampEl) {
        const now = new Date();
        timestampEl.textContent = `Radar: ${now.toLocaleTimeString()}`;
    }
}

function updateZoomDisplay() {
    if (!map) return;
    const currentZoom = map.getZoom();
    const zoomEl = document.getElementById('current-zoom');
    if (zoomEl) {
        zoomEl.textContent = currentZoom.toFixed(1);
    }
}

async function speakHourlyBriefing() {
    if (!speechEnabled) {
        console.log("Hourly briefing skipped - voice alerts disabled");
        return;
    }
    
    console.log("=== HOURLY WEATHER BRIEFING ===");
    
    try {
        const response = await fetch(`${BACKEND_BASE_URL}/api/weather/forecast`);
        
        if (response.ok) {
            const data = await response.json();
            
            if (data.current) {
                const briefingText = `Hourly weather briefing. Current conditions: ${data.current.temperature} degrees. ${data.current.shortForecast}. Wind speed: ${data.current.windSpeed || 'calm'}. ${activeWarnings.length > 0 ? `There are ${activeWarnings.length} active warnings in effect.` : 'No active warnings at this time.'}`;
                
                console.log("Speaking hourly briefing:", briefingText);
                await speakText(briefingText, 'hourly-briefing');
            } else {
                console.warn("No current weather data available for briefing");
            }
        } else {
            console.warn("Backend unavailable for hourly briefing");
            
            const fallbackText = `Hourly weather briefing. Weather data currently unavailable. ${activeWarnings.length > 0 ? `There are ${activeWarnings.length} active warnings in effect.` : 'No active warnings at this time.'}`;
            await speakText(fallbackText, 'hourly-briefing');
        }
    } catch (error) {
        console.error("Error during hourly briefing:", error);
    }
}

function updateWeatherDisplay() {
    if (!currentForecast) {
        let content = `<div class="prediction-section">
            <h5>Enhanced System Status</h5>
            <div>Mapbox GL: <span style="color: #88ff88;">Active</span></div>
            <div>Warning Animation: <span style="color: #88ff88;">Enabled</span></div>
            <div>County Zoom: <span style="color: #88ff88;">Dynamic</span></div>
            <div>Radar: <span style="color: #88ff88;">Live - NEXRAD</span></div>
            <div>Alert Source: <span style="color: #88ff88;">Backend API + NWS</span></div>
            <div>Backend: <span style="color: ${backendConnected ? '#88ff88' : '#ff8888'}">${backendConnected ? 'Connected' : 'Offline'}</span></div>
            <div>Voice Alerts: <span style="color: ${speechEnabled ? '#88ff88' : '#ffff88'}">${speechEnabled ? 'Active' : 'Disabled'}</span></div>
            <div>Speech: <span style="color: #88ff88;">Browser TTS</span></div>
            <div>Hourly Briefing: <span style="color: #88ff88;">Active</span></div>
            <div>15min Alert Check: <span style="color: #88ff88;">Active</span></div>
        </div>`;
        
        document.getElementById('briefing-content').innerHTML = content;
        return;
    }
}
function displayAnalytics() {
    const panel = document.getElementById('analytics-panel');
    const content = `
        <div style="padding: 10px; background: rgba(255,255,0,0.1); border-radius: 5px; margin-bottom: 10px;">
            <h5 style="margin: 0 0 8px 0; color: #ffff88;">System Analytics</h5>
            <div style="margin: 4px 0; display: flex; justify-content: space-between;">
                <span>Backend:</span><span style="color: ${backendConnected ? '#88ff88' : '#ff8888'}">${backendConnected ? 'Online' : 'Offline'}</span>
            </div>
            <div style="margin: 4px 0; display: flex; justify-content: space-between;">
                <span>Speech:</span><span style="color: #88ff88">Browser TTS</span>
            </div>
            <div style="margin: 4px 0; display: flex; justify-content: space-between;">
                <span>15min Check:</span><span style="color: #88ff88">Active</span>
            </div>
        </div>
    `;
    
    document.getElementById('analytics-content').innerHTML = content;
    panel.style.display = 'block';
    
    setTimeout(setupCloseButtons, 100);
}
async function displayPredictions() {
    const panel = document.getElementById('predictions-panel');
    document.getElementById('predictions-content').innerHTML = `
        <div style="text-align: center; padding: 20px;">
            <div style="color: #ffff88;">Loading ML predictions...</div>
        </div>
    `;
    panel.style.display = 'block';
    setTimeout(setupCloseButtons, 100);
    
    try {
        const response = await fetch(`${BACKEND_BASE_URL}/api/ml/predictions`);
        
        if (!response.ok) {
            throw new Error(`Backend returned ${response.status}`);
        }
        
        const data = await response.json();
        
        let statusColor = data.model_trained ? '#88ff88' : '#ff8888';
        let statusIcon = data.model_trained ? 'âœ…' : 'âŒ';
        
        let content = `
            <div style="padding: 12px; background: rgba(${data.model_trained ? '0,255,0' : '255,100,100'},0.15); border-radius: 6px; margin-bottom: 12px; border-left: 4px solid ${statusColor};">
                <h5 style="margin: 0 0 10px 0; color: ${statusColor}; text-align: center;">Machine Learning Status</h5>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                    <div><strong>Model:</strong></div>
                    <div style="color: ${statusColor};">${statusIcon} ${data.model_trained ? 'TRAINED' : 'NOT TRAINED'}</div>
                    
                    <div><strong>Forecasts:</strong></div>
                    <div style="color: #88ffff;">${data.total_forecasts}</div>
                    
                    <div><strong>Verified:</strong></div>
                    <div style="color: #88ffff;">${data.verified_forecasts}</div>
                </div>
            </div>`;
        
        if (data.sample_prediction && data.model_trained) {
            content += `
                <div style="padding: 12px; background: rgba(0,255,255,0.15); border-radius: 6px; margin-bottom: 12px; border-left: 4px solid #00ffff;">
                    <h5 style="margin: 0 0 10px 0; color: #00ffff; text-align: center;">Sample ML Prediction</h5>
                    <div style="font-size: 11px;">
                        <div style="margin: 6px 0;"><strong>Location:</strong> ${data.sample_prediction.area}</div>
                        <div style="margin: 6px 0;"><strong>Risk Level:</strong> <span style="color: #ffff88;">${data.sample_prediction.risk_level}</span></div>
                        <div style="margin: 6px 0;"><strong>ML Probability:</strong> <span style="color: #88ff88; font-size: 16px; font-weight: bold;">${data.sample_prediction.probability}%</span></div>
                    </div>
                </div>`;
        }
        
        if (data.accuracy && Object.keys(data.accuracy).length > 0) {
            content += `
                <div style="padding: 12px; background: rgba(0,255,0,0.1); border-radius: 6px; margin-bottom: 10px;">
                    <h5 style="margin: 0 0 10px 0; color: #88ff88; text-align: center;">Model Accuracy</h5>
                    <div style="font-size: 11px;">`;
            
            for (const [risk, stats] of Object.entries(data.accuracy)) {
                const accuracyColor = stats.accuracy >= 70 ? '#88ff88' : stats.accuracy >= 50 ? '#ffff88' : '#ff8888';
                content += `
                    <div style="margin: 6px 0; padding: 6px; background: rgba(255,255,255,0.05); border-radius: 3px; display: flex; justify-content: space-between;">
                        <span><strong>${risk}:</strong></span>
                        <span style="color: ${accuracyColor}; font-weight: bold;">${stats.accuracy}% (${stats.hits}/${stats.total})</span>
                    </div>`;
            }
            
            content += `</div></div>`;
        }
        
        if (!data.model_trained) {
            content += `
                <div style="padding: 12px; background: rgba(255,200,100,0.15); border-radius: 6px; text-align: center; border-left: 4px solid #ffaa44;">
                    <div style="color: #ffaa44; font-size: 11px; line-height: 1.5;">
                        <strong>Training Required</strong><br>
                        Need at least 20 verified forecasts to train the ML model.<br>
                        Currently have: ${data.verified_forecasts}/20
                    </div>
                </div>`;
        }
        
        document.getElementById('predictions-content').innerHTML = content;
        
        // Update status panel
        const mlStatusEl = document.getElementById('ml-status');
        if (mlStatusEl) {
            mlStatusEl.textContent = data.model_trained ? 'Trained âœ…' : 'Not Trained';
            mlStatusEl.style.color = data.model_trained ? '#88ff88' : '#ff8888';
        }
        
    } catch (error) {
        console.error('Error loading ML predictions:', error);
        document.getElementById('predictions-content').innerHTML = `
            <div style="text-align: center; padding: 20px;">
                <div style="color: #ff8888; margin-bottom: 10px;">âŒ Error Loading Predictions</div>
                <div style="color: #ffaaaa; font-size: 11px;">${error.message}</div>
                <div style="color: #cccccc; font-size: 10px; margin-top: 10px;">
                    Make sure backend is running with ML integration
                </div>
            </div>`;
    }
}
function displayPreferences() {
    const panel = document.getElementById('preferences-panel');
    const content = `
        <div style="margin: 8px 0; padding: 8px; background: rgba(0,255,0,0.1); border-radius: 4px;">
            <h6 style="margin: 0 0 4px 0; color: #88ff88;">Speech-Sync Features:</h6>
            <div style="font-size: 11px;">
                <div>âœ… Map waits for speech completion</div>
                <div>âœ… Proper promise handling</div>
                <div>âœ… Azure TTS integration</div>
                <div>âœ… Browser TTS fallback</div>
                <div>âœ… 15-minute alert re-check</div>
            </div>
        </div>
    `;
    
    document.getElementById('preferences-content').innerHTML = content;
    panel.style.display = 'block';
    
    setTimeout(setupCloseButtons, 100);
}

async function displayHistory() {
    const panel = document.getElementById('history-panel');
    panel.style.display = 'block';
    document.getElementById('history-content').innerHTML = '<div style="text-align: center; padding: 20px;"><div style="color: #ffff88;">Loading weather history...</div></div>';
    setTimeout(setupCloseButtons, 100);
    try {
        const response = await fetch(`${BACKEND_BASE_URL}/api/learning/history`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (data.history && data.history.length > 0) {
            let html = '<div style="font-size: 11px;"><div style="margin-bottom: 12px; padding: 8px; background: rgba(0,255,255,0.2); border-radius: 4px; text-align: center;"><strong style="color: #00ffff;">Total Events: ' + data.count + '</strong></div>';
            data.history.forEach(item => {
                const date = new Date(item.timestamp);
                const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                html += '<div style="margin: 8px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ffff; border-radius: 4px;"><div style="color: #88ffff; font-size: 10px; font-weight: bold; margin-bottom: 4px;">' + formattedDate + '</div><div style="color: #ffffff; font-size: 11px; line-height: 1.4;">' + item.event + '</div></div>';
            });
            html += '</div>';
            document.getElementById('history-content').innerHTML = html;
        } else {
            document.getElementById('history-content').innerHTML = '<div style="text-align: center; padding: 30px;"><div style="color: #ffff88; font-size: 13px; margin-bottom: 10px;">No forecast history available yet</div><div style="color: #cccccc; font-size: 11px; line-height: 1.5;">History will appear here as forecasts are verified.</div></div>';
        }
    } catch (error) {
        console.error("Error loading history:", error);
        document.getElementById('history-content').innerHTML = '<div style="text-align: center; padding: 30px;"><div style="color: #ff8888; font-size: 13px; margin-bottom: 10px;">Error loading history</div><div style="color: #cccccc; font-size: 11px;">' + (backendConnected ? 'Database may be empty' : 'Backend not connected') + '</div></div>';
    }
}
function initWeatherPanelToggle() {
    try {
        const btn = document.getElementById('toggle-briefing-button');
        const panel = document.getElementById('weather-briefing');
        if (!btn || !panel) {
            console.warn("Toggle patch: required elements not found");
            return;
        }
        
        btn.textContent = (panel.style.display === 'none') ? 'Panel: OFF' : 'Panel: ON';
        btn.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            const hidden = panel.style.display === 'none';
            panel.style.display = hidden ? 'block' : 'none';
            const state = hidden ? 'ON' : 'OFF';
            btn.textContent = `Panel: ${state}`;
            console.log(`Enhanced Weather Information panel turned ${state}.`);
        });
        console.log("Toggle patch installed successfully");
    } catch (e) {
        console.error("Toggle patch error:", e);
    }
}

document.addEventListener('DOMContentLoaded', async () => {
    console.log("Initializing Enhanced Mapbox Weather System - Speech Sync + 15min Alert Check");
    
    initializeMap();
    initWeatherPanelToggle();
    
    console.log("Initializing Azure TTS...");
  
    
    console.log("");
    try {
        const response = await fetch(`${BACKEND_BASE_URL}/api/test`);
        if (response.ok) {
            console.log("");
            backendConnected = true;
            await fetchAlerts();
            fetchOutlooks();
        } else {
            throw new Error('Backend test failed');
        }
    } catch (error) {
        console.log("Backend connection failed - using offline mode");
        backendConnected = false;
    }
    
    updateWeatherDisplay();
    
    document.getElementById('enable-voice-button').addEventListener('click', async () => {
    speechEnabled = !speechEnabled;
    document.getElementById('enable-voice-button').textContent = speechEnabled ? 'Voice: ON' : 'Voice: OFF';
    document.getElementById('enable-voice-button').style.backgroundColor = speechEnabled ? 'rgba(0,255,0,0.4)' : 'rgba(255,255,0,0.2)';
    
    if (speechEnabled) {
        const testMessage = "Voice alerts activated with browser text to speech";
        await speakText(testMessage, 'system');
    }
    
    updateWeatherDisplay();
});
    
document.getElementById('analytics-button').addEventListener('click', displayAnalytics);
document.getElementById('predictions-button').addEventListener('click', displayPredictions);
document.getElementById('preferences-button').addEventListener('click', displayPreferences);
document.getElementById('history-button').addEventListener('click', displayHistory);
document.getElementById('outlooks-button').addEventListener('click', toggleOutlooks);
document.getElementById('watches-button').addEventListener('click', toggleWatches);
    
document.getElementById('test-button').addEventListener('click', async () => {

        if (speechEnabled) {
            const testMessage = "Testing speech-synchronized zoom. The map should stay in this position until this message finishes speaking.";
            await speakText(testMessage, 'test');
            alert('Speech synchronization test completed! The system is working correctly.');
        } else {
            alert('Please enable voice alerts first to test speech synchronization.');
        }
    });

    setInterval(fetchAlerts, 15000);
    setInterval(fetchOutlooks, 300000);
    setInterval(updateWeatherDisplay, 5000);
    
    let briefingCountdown = 3600;
  
    
    function updateBriefingCountdown() {
        const minutes = Math.floor(briefingCountdown / 60);
        const seconds = briefingCountdown % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        const briefingEl = document.getElementById('next-briefing');
        if (briefingEl) {
            briefingEl.textContent = `Next: ${timeString}`;
        }
        
        briefingCountdown--;
        if (briefingCountdown < 0) {
            console.log("Hourly briefing countdown reached zero - triggering automated briefing");
            briefingCountdown = 3600;
            speakHourlyBriefing();
        }
    }
    
    updateBriefingCountdown();
    setInterval(updateBriefingCountdown, 1000);
    
    let alertCheckCountdown = 900;
    
    function updateAlertCheckCountdown() {
        const minutes = Math.floor(alertCheckCountdown / 60);
        const seconds = alertCheckCountdown % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        const alertCheckEl = document.getElementById('next-alert-check');
        if (alertCheckEl) {
            alertCheckEl.textContent = `Alert Check: ${timeString}`;
        }
        
        alertCheckCountdown--;
        if (alertCheckCountdown < 0) {
            console.log("15-minute warning check countdown reached zero - re-zooming to most severe warning");
            alertCheckCountdown = 900;
            
            performPeriodicAlertCheck();
        }
    }
    
    updateAlertCheckCountdown();
    setInterval(updateAlertCheckCountdown, 1000);
    
    console.log("Enhanced Mapbox Weather System ready - Speech synchronization FIXED + 15-min WARNING checks enabled!");
});

console.log("=".repeat(60));
console.log("SPEECH SYNCHRONIZATION FIXED + 15-MIN WARNING CHECK");
console.log("=".repeat(60));
console.log("âœ… Map stays zoomed until speech completes");
console.log("âœ… Proper Promise handling implemented");
console.log("âœ… Azure TTS waits for audio completion");
console.log("âœ… Browser TTS waits for audio completion");
console.log("âœ… 15-minute periodic WARNING re-zoom enabled");
console.log("âœ… Zooms to most severe active WARNING every 15 min");
console.log("âœ… Voice reminder on re-zoom (if voice enabled)");
console.log("=".repeat(60));
</script>

<script>
async function classifyAlert(alert) {
    try {
        const response = await fetch("http://localhost:5000/api/ml/severe", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                severity: alert.severity,
                urgency: alert.urgency,
                certainty: alert.certainty,
                event: alert.event
            })
        });
        return await response.json();
    } catch (e) {
        console.error("Severe classification failed:", e);
        return { severe: false, probability: 0.0 };
    }
}
</script>

</body>
</html>